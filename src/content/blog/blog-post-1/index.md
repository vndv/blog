---
title: "Лучшие практики написания SQL-запросов: Как структурировать свой код"
pubDate: 2023-07-17
tags:
  - "SQL"
description: "Лучшие практики написания SQL-запросов: Как структурировать свой код"
---

*В этой статье основное внимание уделяется тому, как правильно писать SQL-запросы и как их  можно улучшить, в частности, когда речь идет о производительности и читаемости.*

Язык структурированных запросов (SQL) — абсолютно необходимый навык в индустрии науки о данных. Необходимо не только уметь писать запросы, но и убедиться, что они производительны, быстры и удобочитаемы. Поэтому важно знать, как эффективно писать SQL-запросы.

В этой статье будут представлены лучшие практики оптимизации SQL-запросов. Даже если ваш SQL-код работает правильно, его все равно можно улучшить, особенно в отношении производительности и читаемости. Это важно, потому что на технических собеседованиях цель заключается не только в проверке того, способен ли кандидат предложить работающее решение проблемы, но и в том, может ли он подготовить эффективное и понятное решение. То же самое верно и для рабочей среды: сделать запросы быстрыми и понятными для других так же важно, как и сделать их правильными.

Давайте рассмотрим реальный пример вопросов собеседований по Data Science, которые можно решить с помощью SQL-запросов. У нас есть решение, которое дает правильный вывод, но оно очень неэффективно и трудно читаемо. Затем мы рассмотрим несколько ключевых рекомендаций по написанию SQL-запросов и применим их к коду, чтобы улучшить его и использовать в качестве ответа на вопросы на собеседовании.

### Пример вопроса на собеседовании по SQL

#### Premium vs Freemium

Microsoft       Hard       Interview Questions       ID 10300
<hr></hr>

*Найдите общее количество загрузок для бесплатных и платных пользователей по дате. Отобразите только те записи, в которых количество загрузок для бесплатных пользователей больше, чем для платных. Вывод должен быть отсортирован по дате в порядке возрастания и содержать три столбца: дата, количество бесплатных загрузок и количество платных загрузок.*

> #### Tables: ms_user_dimension, ms_acc_dimension, ms_download_facts

[Ссылка на задание](https://platform.stratascratch.com/coding/10300-premium-vs-freemium)

Мы используем этот вопрос на собеседовании по SQL в качестве примера из технических собеседований в Microsoft, который называется "Premium vs Freemium". Задача заключается в том, чтобы найти общее количество загрузок для платных и неплатящих пользователей по дате и включить только те записи, где у неплатящих клиентов больше загрузок, чем у платных. Кроме того, этот вопрос связан с набором данных, разделенным на три таблицы, которые необходимо объединить.


### Исходное решение

У нас уже есть исходное решение этой проблемы в SQL, которое мы будем использовать в качестве отправной точки. Мы не будем объяснять, как это решение работает или как его можно получить, так как это не является целью этой статьи. Вместо этого мы будем использовать его как иллюстрацию синтаксических приемов, универсальных для любого SQL-запроса.

Этот SQL-запрос можно использовать как решение поставленной задачи:

``` sql
SELECT date, "NonPaying",
             paying
FROM
  (SELECT p.date,
          p.sum AS paying,
          n.nonpaying AS "NonPaying"
   FROM
     (SELECT date, sum(downloads)
      FROM ms_user_dimension a
      INNER JOIN ms_acc_dimension b ON a.acc_id = b.acc_id
      INNER JOIN ms_download_facts c ON a.user_id=c.user_id
      WHERE paying_customer = 'yes'
      GROUP BY date
      ORDER BY date) p
   JOIN
     (SELECT date, sum(downloads) AS nonpaying
      FROM ms_user_dimension a
      INNER JOIN ms_acc_dimension b ON a.acc_id = b.acc_id
      INNER JOIN ms_download_facts c ON a.user_id=c.user_id
      WHERE paying_customer = 'no'
      GROUP BY date
      ORDER BY date) n ON p.date = n.date
   ORDER BY p.date) s
GROUP BY date, "NonPaying",
               paying
HAVING ("NonPaying" - paying) >0
ORDER BY date ASC
```

[Перейдем на платформу для выполнения запроса](https://platform.stratascratch.com/coding/10300-premium-vs-freemium?code_type=1) (необходима регистрация)

Не беспокойтесь, если вы сначала не поймете, что здесь происходит. Это решение намеренно длинное и запутанное, и задача заключается в том, чтобы оптимизировать его, используя лучшие практики  SQL. Но самое интересное, что это решение работает — мы можем его запустить и посмотреть, сколько загрузок от платных и неплатных клиентов было за каждую дату. Однако интервьюер, вероятно, не обрадуется такому ответу. Давайте посмотрим, какие лучшие практики написания SQL-запросов нам здесь помогут и как повысить наши шансы произвести впечатление на интервьюера.

### Лучшие практики написания SQL-запросов: как структурировать свой код



![](./images/sql.png)

#### 1. Удалите несколько вложенных запросов

Даже не понимая, что именно делает данный код, мы видим, что он имеет несколько вложенных запросов. Есть основной запрос, в котором выбираются три столбца. Затем в его предложении FROM есть еще один длинный запрос, называемый внутренним запросом. У него есть ‘алиас’ «s». Но тогда сам этот внутренний запрос «s» также имеет два дополнительных и почти идентичных внутренних запроса: «p» и «n». Они объединяются вместе с помощью оператора JOIN. Хотя иметь один внешний запрос и один внутренний запрос абсолютно нормально, более двух запросов, вложенных друг в друга, считаются не очень читабельными, и их следует избегать.

Один из подходов к устранению такого количества вложенных запросов заключается в том, чтобы определить некоторые или все из них в форме общих табличных выражений или CTE - конструкций, которые используют ключевое слово WITH и позволяют повторно использовать один запрос несколько раз. Таким образом, наш первый шаг - превратить все три вложенных запроса "s", "p" и "n" в CTE.

```sql
WITH p AS
  (SELECT date, sum(downloads)
   FROM ms_user_dimension a
   INNER JOIN ms_acc_dimension b ON a.acc_id = b.acc_id
   INNER JOIN ms_download_facts c ON a.user_id=c.user_id
   WHERE paying_customer = 'yes'
   GROUP BY date
   ORDER BY date),

     n AS
  (SELECT date, sum(downloads) AS nonpaying
   FROM ms_user_dimension a
   INNER JOIN ms_acc_dimension b ON a.acc_id = b.acc_id
   INNER JOIN ms_download_facts c ON a.user_id=c.user_id
   WHERE paying_customer = 'no'
   GROUP BY date
   ORDER BY date),

     s AS
  (SELECT p.date,
          p.sum AS paying,
          n.nonpaying AS "NonPaying"
   FROM p
   JOIN n ON p.date = n.date
   ORDER BY p.date)

SELECT date, "NonPaying",
             paying
FROM s
GROUP BY date, "NonPaying",
               paying
HAVING ("NonPaying" - paying) >0
ORDER BY date ASC
```

#### 2. Обеспечьте согласованность псевдонимов (’алиасов’)

В SQL псевдонимы можно назначать столбцам, запросам и таблицам, чтобы изменить их первоначальные имена. Их необходимо использовать при объединении таблиц с одинаковыми именами столбцов, чтобы избежать двусмысленности в именах столбцов. Псевдонимы также полезны для облегчения понимания кода другими и для замены имен столбцов по умолчанию при использовании аналитических функций, таких как SUM() или COUNT().

Также есть несколько неофициальных правил относительно псевдонимов, которых следует придерживаться, поскольку неправильно использованный псевдоним может скорее сбить с толку, чем помочь. Начнем с псевдонимов таблицы и запроса. Хорошо, когда это немного больше, чем просто одна буква, и он позволяет понять, что находится в таблице или что выдает запрос. В нашем случае первый CTE, который в настоящее время называется «p», используется для подсчета количества загрузок, сделанных платными клиентами, поэтому более информативным названием будет, например, «paying». Стоит отметить, что псевдонимы, хотя и информативны, не должны быть слишком длинными, например, «paying_customers» может быть немного длинным. Затем второй CTE, «n», такой же, но для неплатящих клиентов, поэтому, следуя схеме, его можно назвать «nonpaying».

Наконец, CTE «s» объединяет два значения: количество загрузок платных и бесплатных клиентов, но пока не фильтрует их, потому что это происходит в основном запросе. Таким образом, его имя может быть, например, «all_downloads».

Теперь обратите внимание, что это еще не все таблицы, которым присвоены псевдонимы. Это связано с тем, что в первых двух CTE мы объединяем три таблицы друг с другом, и, поскольку они имеют общие имена столбцов, им нужно дать псевдонимы. В настоящее время это просто «a», «b» и «c», но более информативными названиями будут «users», «accounts» и «downloads» — аббревиатура здесь, потому что в этой таблице уже есть столбец «downloads».

Последнее, что касается псевдонимов таблиц, — это согласованность их использования. Обычно лучше либо использовать их со всеми именами столбцов, либо только в абсолютно необходимых местах (например, только при определении JOIN), или вообще не использовать. Давайте решим использовать псевдонимы таблиц во всех случаях, когда объединены несколько таблиц, то есть во всех CTE, и не использовать их, когда все столбцы поступают только из одной таблицы, как в основном запросе.

```sql
WITH paying AS
  (SELECT downlds.date, sum(downlds.downloads)
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   WHERE accounts.paying_customer = 'yes'
   GROUP BY downlds.date
   ORDER BY downlds.date),

     nonpaying AS
  (SELECT downlds.date, sum(downlds.downloads) AS nonpaying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   WHERE accounts.paying_customer = 'no'
   GROUP BY downlds.date
   ORDER BY downlds.date),

     all_downloads AS
  (SELECT paying.date,
          paying.sum AS paying,
          nonpaying.nonpaying AS "NonPaying"
   FROM paying
   JOIN nonpaying ON paying.date = nonpaying.date
   ORDER BY paying.date)

SELECT date, "NonPaying",
             paying
FROM all_downloads
GROUP BY date, "NonPaying",
               paying
HAVING ("NonPaying" - paying) >0
ORDER BY date ASC
```

Это были псевдонимы таблицы и запроса. Теперь давайте посмотрим на псевдонимы, присвоенные столбцам. Во-первых, дадим псевдонимы результатам аналитических функций. Рассмотрим первый запрос. В нем есть функция SUM(), но к ней не добавлен псевдоним, хотя позже этот столбец используется повторно. Поэтому в CTE all_downloads нам нужно написать pay.sum, чтобы выбрать его. Добавим псевдоним, например, n_paying.

Другое дело — поддерживать согласованность псевдонимов столбцов в именах, а также избегать конфликтов с другими псевдонимами. Как и в CTE nonpaying, есть функция SUM(), которая правильно назначается как псевдоним, но этот псевдоним совпадает с псевдонимом CTE, что может сбивать с толку. Давайте придерживаться того же соглашения об именах, что и раньше, и изменим этот псевдоним на n_nonpaying.

Теперь в CTE all_downloads происходит много всего. Во-первых, псевдоним «paying», назначенный второму столбцу, совпадает с псевдонимом одного из CTE. И сразу после этого псевдоним третьего столбца — «NonPaying» в кавычках. Хотя SQL позволяет нам назначать такие псевдонимы, использовать такие псевдонимы опасно, потому что каждый раз, когда мы хотим использовать его повторно, нам нужно снова использовать кавычки и сопоставлять все заглавные и строчные буквы в псевдониме. Мы могли бы изменить эти два псевдонима на что-то другое и без кавычек. Но на самом деле даже не обязательно использовать эти алиасы, ведь аналитических функций здесь нет, поэтому имена столбцов из предыдущих, ‘n_paying’ и n_nonpaying’ остаются прежними и на них можно ссылаться в основном запросе, не вызывая проблем.

```sql
WITH paying AS
  (SELECT downlds.date, sum(downlds.downloads) AS n_paying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   WHERE accounts.paying_customer = 'yes'
   GROUP BY downlds.date
   ORDER BY downlds.date),

     nonpaying AS
  (SELECT downlds.date, sum(downlds.downloads) AS n_nonpaying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   WHERE accounts.paying_customer = 'no'
   GROUP BY downlds.date
   ORDER BY downlds.date),

     all_downloads AS
  (SELECT paying.date,
          paying.n_paying,
          nonpaying.n_nonpaying
   FROM paying
   JOIN nonpaying ON paying.date = nonpaying.date
   ORDER BY paying.date)

SELECT date, n_nonpaying,
             n_paying
FROM all_downloads
GROUP BY date, n_nonpaying,
               n_paying
HAVING (n_nonpaying - n_paying) >0
ORDER BY date ASC
```

Не существует конкретных правил относительно форматирования псевдонимов, но большинство людей используют только строчные буквы и знак подчеркивания, если псевдоним состоит из нескольких слов.

#### 3. Удалите ненужные предложения ORDER BY

Теперь, когда мы позаботились о псевдонимах, давайте начнем сокращать объем кода в нашем решении. Первая вещь немного второстепенна, но все же способствует удобочитаемости запроса. Речь идет о предложении ORDER BY. Оно используются для сортировки данных в таблице. В конце концов, иногда необходимо использовать предложение ORDER BY в сочетании с оконной функцией или при выборе верхних строк таблицы с помощью ключевого слова LIMIT. Мы также можем захотеть расположить окончательные результаты в определенном порядке , иногда это даже может быть требованием.

Но если у нас есть несколько запросов, обычно нет необходимости добавлять одно и то же предложение ORDER BY в каждый из них. Посмотрите на наш запрос, например, мы сортируем результаты по дате, но делаем это во всех возможных запросах и подзапросах. Это не только бесполезно, но и неэффективно, потому что каждое предложение ORDER BY добавляет немного сложности и, следовательно, времени, необходимого для выполнения запроса, особенно при работе с большими наборами данных. Поэтому, если у каждого запроса есть собственное предложение сортировки, хорошо подумать, действительно ли оно необходимо. В нашем случае можно оставить его только в последнем запросе.

```sql
WITH paying AS
  (SELECT downlds.date, sum(downlds.downloads) AS n_paying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   WHERE accounts.paying_customer = 'yes'
   GROUP BY downlds.date),

     nonpaying AS
  (SELECT downlds.date, sum(downlds.downloads) AS n_nonpaying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   WHERE accounts.paying_customer = 'no'
   GROUP BY downlds.date),

     all_downloads AS
  (SELECT paying.date,
          paying.n_paying,
          nonpaying.n_nonpaying
   FROM paying
   JOIN nonpaying ON paying.date = nonpaying.date)

SELECT date, n_nonpaying,
             n_paying
FROM all_downloads
GROUP BY date, n_nonpaying,
               n_paying
HAVING (n_nonpaying - n_paying) >0
ORDER BY date ASC
```

#### 4. Удалите ненужные подзапросы и CTE

Теперь есть куда более важная тема, чем удаление ненужных предложений ORDER BY — удаление ненужных подзапросов и CTE. Мы говорили о них раньше, когда разбивали вложенные запросы на CTE, но тогда мы просто оставили их как есть, не анализируя, действительно ли они нам нужны.

Оказывается, иногда два запроса делают одно и то же или могут быть объединены в один с помощью других предложений или операторов. В конце концов, каждый запрос увеличивает сложность и время, необходимое для выполнения запроса. В нашем случае четыре разных запроса приводят к тому, что движку четыре раза требуется доступ к таблице для выбора данных из нее. Более того, в трех из этих запросов мы объединяем несколько таблиц, используя JOIN — операции, которые могут занять много времени, особенно если таблицы большие.

Чтобы уменьшить количество запросов в нашем случае, можно пойти двумя путями. Одной из возможностей было бы объединить запрос all_downloads с основным запросом. В конце концов, эти два запроса почти идентичны, и если бы мы только добавили фильтр, поэтому выражение, говорящее, что разница между n_nonpaying и n_paying должна быть больше 0, к запросу в all_downloads, дало бы те же результаты. Мы могли бы безопасно избавиться от CTE all_downloads и вместо этого объединить ‘paying’ и ‘nonpaying’ CTE в основном запросе. Таким образом, мы можем сократить количество запросов до 3. Но можем ли мы добиться большего?

Можем, потому что оказывается, что первые два CTE, а именно «paying» и «nonpaying», могут быть выполнены в CTE «all_downloads». Это потому, что эти первые два CTE почти идентичны, а главное отличие заключается в предложении WHERE. Мы выбираем одни и те же типы данных из одних и тех же таблиц, но в разных условиях. Но в SQL есть другой способ выбора и даже выполнения арифметических операций над данными с использованием разных условий только в одном запросе: нам нужно использовать CASES.

Мы можем использовать их для преобразования строк «yes» и «no» из столбца «paying_customer» в количество загрузок, а затем суммировать их, чтобы получить общее количество. Это означает, что весь первый CTE можно заменить следующим фрагментом кода:

```sql
sum(CASE
    WHEN paying_customer = 'yes' THEN downloads
    END)
```

Это будет очень похоже на ‘non-paying’ клиентов. Обе эти инструкции могут быть выполнены прямо в CTE all_downloads, если мы объединим три таблицы, пользователей, учетные записи и загрузки и включим оператор данных GROUP BY также в это CTE.

```sql
WITH all_downloads AS
  (SELECT downlds.date,
          sum(CASE
                WHEN accounts.paying_customer = 'yes' THEN downlds.downloads
            END) AS n_paying,
          sum(CASE
                WHEN accounts.paying_customer = 'no' THEN downlds.downloads
            END) AS n_nonpaying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   GROUP BY downlds.date)

SELECT date, n_nonpaying,
             n_paying
FROM all_downloads
GROUP BY date, n_nonpaying,
               n_paying
HAVING (n_nonpaying - n_paying) >0
ORDER BY date ASC
```

С этими изменениями у нас осталось всего два запроса, один набор из нескольких JOIN и два случая, когда данные нужно выбирать из таблицы вместо четырех. В то же время мы не можем решить этот вопрос, используя только один запрос, потому что столбцы «n_paying» и «n_nonpaying» должны быть определены в одном запросе, прежде чем использоваться в фильтре в другом запросе.

#### 5. HAVING vs WHERE

Говоря о производительности и эффективности, в нашем запросе есть еще одна деталь, которая  замедляет его. Эта деталь — предложение HAVING в основном запросе. Но почему именно HAVING, а не WHERE? Эти два выражения очень похожи друг на друга и позволяют фильтровать данные на основе некоторых условий. Как и в этом случае, когда разница между значениями n_nonpaying и n_paying должна быть больше 0. Это условие можно определить как с ключевыми словами WHERE, так и с ключевыми словами HAVING, но одно из них лучше подходит в этой ситуации. Ключевое отличие состоит в том, что предложение HAVING может включать агрегатные функции, например. SUM() или COUNT(). Он позволяет создавать условия на основе суммы, среднего, минимального или максимального значения или количества элементов в наборе данных или в разделах, определенных с помощью предложения GROUP BY. Именно по этой причине предложение HAVING всегда должно сопровождаться оператором GROUP BY.

Чего не знают многие пользователи SQL, так это того, что предложение HAVING следует использовать только тогда, когда необходимо создать условие с помощью агрегатной функции. Во всех остальных случаях предложение WHERE является лучшим выбором? Почему? Все упирается в эффективность. Предложение WHERE выполняется вместе с остальной частью запроса, поэтому, если это более эффективно, механизм SQL может решить ограничить количество экземпляров в наборе данных, используя условие из WHERE, прежде чем выполнять другие операции. С другой стороны, оператор HAVING всегда выполняется после запроса, хотя в коде он является его частью. Это почти всегда приводит к немного большему времени вычислений.

В нашем примере условие основано на арифметической операции с двумя столбцами, но это не то же самое, что агрегатная функция. По этой причине это условие вполне может быть определено в предложении WHERE. При этом, помимо повышения эффективности, мы также избавляемся от лишнего предложения GROUP BY.

```sql
WITH all_downloads AS
  (SELECT downlds.date,
          sum(CASE
                WHEN accounts.paying_customer = 'yes' THEN downlds.downloads
            END) AS n_paying,
          sum(CASE
                WHEN accounts.paying_customer = 'no' THEN downlds.downloads
            END) AS n_nonpaying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   GROUP BY downlds.date)

SELECT date, n_nonpaying,
             n_paying
FROM all_downloads
WHERE (n_nonpaying - n_paying) > 0
ORDER BY date ASC
```

#### 6. Форматирование текста

Последнее, что повышает читабельность запросов, — это форматирование кода. Эта часть не имеет ничего общего с производительностью, а связано с простотой понимания кода другими людьми. Это также та деталь, о которой все забывают при написании SQL-запроса, особенно в стрессовой обстановке собеседования. Или все привыкли к другому стилю форматирования текста и путаются, видя другие подходы.

В SQL нет официальных правил форматирования текста в запросах, но есть некоторые неофициальные рекомендации, которым следуют многие пользователи SQL. Вероятно, наиболее распространенным и известным является то, что все ключевые слова, такие как SELECT, FROM, WHERE, GROUP BY, ORDER BY и т. д., должны быть написаны заглавными буквами. Это также относится к другим встроенным ключевым словам, которые появляются внутри предложений, таких как JOIN, AS, IN, ON или ASC и DESC. Когда дело доходит до названий функций, таких как SUM() или COUNT(), нет единого мнения о том, должны ли они быть написаны полностью заглавными или только строчными буквами, но, вероятно, лучше использовать их также с заглавной буквы. 

Еще одно важное правило заключается в том, что, хотя для работы кода это и не обязательно, каждое предложение, такое как SELECT, FROM, WHERE, GROUP BY и т. д., должно находиться в новой строке. Для дальнейшего повышения удобочитаемости также рекомендуется иметь новую строку для каждого имени столбца в предложении SELECT. Более того, если мы используем подзапросы или CTE, хорошим подходом является использование отступов, чтобы визуально отличить внутреннюю часть скобки от остальной части запроса.

Код из нашего примера в основном уже хорошо отформатирован. Но мы по-прежнему можем добавлять новые строки в предложение SELECT основного запроса и использовать заглавные буквы в именах функций SUM().

```sql
WITH all_downloads AS
  (SELECT downlds.date,
          SUM(CASE
                WHEN accounts.paying_customer = 'yes' THEN downlds.downloads
            END) AS n_paying,
          SUM(CASE
                WHEN accounts.paying_customer = 'no' THEN downlds.downloads
            END) AS n_nonpaying
   FROM ms_user_dimension users
   INNER JOIN ms_acc_dimension accounts ON users.acc_id = accounts.acc_id
   INNER JOIN ms_download_facts downlds ON users.user_id=downlds.user_id
   GROUP BY downlds.date)

SELECT date, 
       n_nonpaying,
       n_paying
FROM all_downloads
WHERE (n_nonpaying - n_paying) > 0
ORDER BY date ASC
```

Мы знаем, что иногда бывает сложно запомнить все правила форматирования текста или настроить все вручную, например, сделать ключевые слова заглавными или добавить таблицы. Таким образом, полезно иметь привычку использовать эти правила форматирования при написании SQL-запросов, потому что это облегчает понимание кода для нас самих и позволяет писать более читаемый код на собеседованиях.

#### Заключение

В заключение, вот еще раз список лучших практик написания SQL-запросов:

- Удалить несколько вложенных запросов
- Обеспечьте согласованность псевдонимов
- Удалите ненужные предложения ORDER BY
- Удалить ненужные подзапросы
- Если возможно, используйте WHERE, а не HAVING.
- Отформатируйте свой код в соответствии с лучшими практиками

Более того, при удалении нескольких вложенных запросов вы можете превратить их в CTE — хорошее эмпирическое правило заключается в том, что один подзапрос — это хорошо, но несколько подзапросов или подзапрос, повторяющийся несколько раз, должны стать CTE

Согласованность псевдонимов включает в себя их информативность, длину более 1 буквы, но и не слишком длинные. Будьте последовательны, используете ли вы псевдонимы или нет. Добавляйте псевдонимы к столбцам, созданным аналитическими функциями. Придерживайтесь некоторых соглашений об именах и избегайте столбцов или таблиц, использующих один и тот же псевдоним. Используйте строчные буквы для псевдонимов и символы подчеркивания, если в нем несколько слов. Не используйте кавычки для определения псевдонима.

Чтобы удалить предложение ORDER BY, помните, что часто его не нужно повторять в нескольких запросах. Если это так, посмотрите, возможно ли иметь его только в последнем.

Иногда подзапросы или CTE могут быть объединены вместе. Ищите подзапросы, которые выглядят одинаково или приводят к одним и тем же столбцам — часто их проще всего комбинировать. Один из приемов — заменить предложение WHERE на CASE.

Используйте предложение HAVING только в сочетании с агрегатными функциями, почти во всех остальных случаях следует выбирать WHERE.

При форматировании текста запроса не забудьте написать ключевые слова и, возможно, функции заглавными буквами, псевдонимы, имена таблиц и столбцов строчными буквами. Каждое предложение и, возможно, каждый столбец в предложении SELECT должны находиться в новой строке. Используйте табуляцию для отображения подзапросов и CTE